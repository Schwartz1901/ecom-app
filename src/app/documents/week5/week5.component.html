<div class="wrapper">
    <div class="title">
        <h1>Week 5: Microservices</h1>
        <div class="summary-section">
            <p>
                Microservices design
            </p>
        </div>
    </div>
    <hr class="divider">
    <div class="goals">
        <h2>Goals:</h2>
        <app-checklist [storageKey]="'week5'"></app-checklist>
    </div>
    <hr class="divider">
    <div class="main-content">
        <section class="intro">
            <h2><a href="https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices">Introduction to Microservices</a></h2>
            <h3>Microservices architecture</h3>
            <p>Microservices are a popular architectural style for building applications that are resilient, highly scalable, independently deployable, and able to evolve quickly.</p>
            <p>A microservices architecture consists a collection of small, autonomous services</p>
            <p>Each service is self-contained and should implement a single business capability within a bounded context</p>
            <p>A bounded context is a natural division within a business and provides an explicit boundary within which a domain model exists.</p>
            <img src="https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/images/microservices-logical.svg" alt="Micro service">
            <h3>Microservices</h3>
            <p>Microservices are small, independent, and loosely coupled components that a single small team of developers can write and maintain. </p>
            <p>Each service is managed as a separate codebase, which allows a small team to handle it efficiently. Because services can be deployed independently, teams can update existing services without rebuilding or redeploying the entire application. </p>
            <p>Unlike traditional models that have a centralized data layer, microservices are responsible for persisting their own data or external state. They communicate through well-defined APIs, which keeps internal implementations hidden from other services.</p>
            <p> This architecture also supports polyglot programming, which means that services don't need to share the same technology stack, libraries, or frameworks.</p>
            <h3>Keys</h3>
            <ul>
                <li>Microservices are a architecture consists of small and independent services</li>
                <li>Services communicate through well-defined APIs</li>
                <li>Each service is <strong>self-contained</strong>: handle a specific business capacity</li>
                <li>Each service is <strong>independently deployable</strong>: Can be deployed, developed and scaled seperately</li>
                <li>Each service is <strong>autonomous</strong>: Own its data logic</li>
            </ul>
            <h3>Why microservices are used:</h3>
            <ul>
                <li>Each service can be scaled independenly -> Scalability</li>
                <li>Service can be developed and deploy independenly</li>
                <li>Minimizing system-wide failure</li>
                <li>Various tech stacks -> Flexibility</li>
            </ul>
            <h3>Principles of Microservice</h3>
            <p>Source:</p>
            <p><a href="https://developers.redhat.com/articles/2022/01/11/5-design-principles-microservices#five_design_principles_for_microservices">5 Design principles</a></p>
            <p><a href="https://dev.to/adityabhuyan/key-principles-of-microservice-architecture-a-detailed-guide-128g">Key principles of Microservice architecture</a></p>
            <h4>Single Responsibitlity</h4>
            <p>"A microservice should do one thing and one thing only."</p>
            <p>For example, if the microservice is intended to support authentication, it should do authentication only.</p>
            <p>This means that its interface should expose only access points that are relevant to authentication. And internally, the microservice should have authentication behavior only. </p>
            <p>For example, there should be no side behavior such as providing employee contact information in the authentication response.</p>
            <p>Having a single concern makes the microservice easier to maintain and scale.</p>
            <h4>Discrete microservices boundaries</h4>
            <p>A microservice must have clear boundaries separating it from its environment</p>
            <p>all logic and data relevant to a microservice's single concern must be encapsulated into a single deployment unit.</p>
            <p>Deployment units: .NET DLL, JAR file, Node.js Packages...</p>
            <p>Also, a discrete microservice is hosted in a distinct source control repository and is subject to its own CI/CD process.</p>
            <p>The microservice becomes part of a larger application after deployment</p>
            <p>THe microservice is isolated from all others during development to testing</p>
            <h4>Transportable</h4>
            <p>A transportable microservice can be moved from one runtime environment to another with little effort.</p>
            <p>The container image can be targeted to any destination from that image repository, so a variety of applications can use the image.</p>
            <p>No "Work on my machine, why not yours?" situation. Working the same on dev, test, deployed</p>
            <p>This transportable feature also makes microservices easier to use in an automated or declarative deployment process.</p>
            <h4>Carry-it-own-data</h4>
            <p>A microservice should have its own data storage mechanism that is isolated from all other microservices.</p>
            <p>The only way data can be shared with other microservice is by way of a public interface that the microservice publishes.</p>
            <h4>Inheritly ephemeral</h4>
            <p>A microservice is ephemeral means that it can be created, destroyed, and replenished on-demand on a target easily, quickly, and with no side effects</p>
            <p>T he standard operating expectation is that microservices come and go all the time</p>
            <p>Two basic implication:</p>
            <p> - Implementing graceful startup and shutdown behavior within the microservice.</p>
            <p> - Rely on runtime configuration settings to define external dependencies</p>
            <h4>Some others</h4>
            <ul>
                <li>Observability: Built-in support for logging, monitoring, tracing, and metrics.</li>
                <li>Resilience and Fault Isolation: The principle of fault isolation ensures that a failure in one service does not bring down the entire system</li>
                <li>API-First Design: Ensure that services can interact with each other seamlessly</li>
                <li>CI/CD: Have automated processes for building, testing, and deploying services</li>
            </ul>
        </section>
        <br>
        <section class="compare-to-monolith">
            <h2>Comparative Analysis with Monolith architecture</h2>
            <p><strong>Reviwew:</strong> A Monolith is a single unified applicatio that all features (UI, business logic, database access) are in one codebase.</p>
            <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240219192035/Monolithic-Architecture.webp" alt="Monolith example">
            <h3>Comparision between Monolith and Microservice</h3>
            <div class="diff-table">
                <table border="1">
                    <thead>
                        <tr>
                        <th>Aspects</th>
                        <th>Monolith</th>
                        <th>Microservices</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <td>Architecture</td>
                        <td>Single-tier architecture</td>
                        <td>Multi-tier architecture</td>
                        </tr>
                        <tr>
                        <td>Size</td>
                        <td>Large, all components tightly coupled</td>
                        <td>Small, loosely coupled components</td>
                        </tr>
                        <tr>
                        <td>Deployment</td>
                        <td>Deployed as a single unit</td>
                        <td>Each can be deployed independently</td>
                        </tr>
                        <tr>
                        <td>Scalability</td>
                        <td>Horizontal scalling can be challenging</td>
                        <td>Easier to scale</td>
                        </tr>
                        <tr>
                        <td>Development</td>
                        <td>Initially simplier</td>
                        <td>Complex due to manage multiple services</td>
                        </tr>
                        <tr>
                        <td>Techstack</td>
                        <td>Limited within project</td>
                        <td>Can use various technologies and languages</td>
                        </tr>
                        <tr>
                        <td>Fault tolerance</td>
                        <td>Entire application may fail if a part fails</td>
                        <td>A part may fail without affecting others</td>
                        </tr>
                        <tr>
                        <td>Maintenance</td>
                        <td>Easier due to its simplicity</td>
                        <td>Require more effors due to managing multiple services</td>
                        </tr>
                        <tr>
                        <td>Flexibility</td>
                        <td>Less flexible, components are tightly coupled</td>
                        <td>More flexible, components can be developed, deploy and upgraded individually</td>
                        </tr>
                        <tr>
                        <td>Communication</td>
                        <td>Communication between each components is faster</td>
                        <td>Depends on network condition</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        
        </section>
        <section class="key-concepts">
            <h2> Key Concepts: Service autonomy, Scalability, Resilience</h2>
            <h3> <a href="https://www.codingknownsense.com/microservices-design-principle-autonomy/">Service Autonomy</a></h3>
            <p>Autonomy in microservices refers to the degree of independence and self-sufficiency that each individual microservice possesses within a microservices architecture.</p>
            <p>Some characteristic:</p>
            <ul>
                <li>Has it own database and codebase. No shared code implemtation or data</li>
                <li>Can be built, test, deployed independently</li>
                <li>Can be deployed on different environments and scaled seperately</li>
                <li>Owns its business logic and rules within a bounded domain</li>
            </ul>
            To archive the autonomy, follow these key design practices
            <h4>Loose coupling</h4>
            <p>One of the key design approaches for this is loose coupling where we make sure each one of our microservices is independent from other services because they have limited knowledge about the inner workings, i.e. the code, within other services.</p>
            <img src="https://www.codingknownsense.com/wp-content/uploads/2023/09/image-27-1024x639.png" alt="Service autonomy">
            <p>The easiest way of achieving this is by having our microservices physically separate from each other by having them communicate with each other using the network and by using proven open network communication protocols like HTTP.</p>
            <p>To further loosen the coupling, make sure that the amount of HTTP calls that required in order to fetch data or carry out functionalities is minimum</p>
            <p>Each service has it own database and that is not shared with other services. The only way to get that data is to talk with the service itself</p>
            <h4>Contracts and Interfaces</h4>
            <p>Calls between services have stable request and response and remain stable even the service is changing</p>
            <img src="https://www.codingknownsense.com/wp-content/uploads/2023/09/image-30-768x505.png" alt="autonomous: contracts and interfaces">
            <p>Making sure that we expose the minimal amount of data, and only data that actually required from outside. Keep inner data internally</p>
            <h4>Backward compactability</h4>
            <p>If we have breaking changes (means changes in services required changes in somewhere else), make sure the clients use that changed service are not affected</p>
            <p>Keep providing and supporting the old versions so that the clients do not have to actually change until they want to</p>
            <p>have a versioning strategy (ex: Semmatic versioning (3-digit versioning), ...)</p>
            <img src="https://www.codingknownsense.com/wp-content/uploads/2023/09/image-33-768x454.png" alt="autonomous: backward compactability">
            <p>Quite achivable with APIs-based microservice where we can have multiple duplicated endpoints seperated by version number</p>
            <h4>Stateless</h4>
            <p>Microservice instances do not have any in-memory data</p>
            <p>Be able to replace any microservice at anytime without worrying about what are in the memory of the instance</p>
            <h4>Conceptual microservice</h4>
            <p>Microservice is not only a single application, but can also be a combination of multiple applications</p>
            <img src="https://www.codingknownsense.com/wp-content/uploads/2023/09/image-34-1024x586.png" alt="conceptual-microservice">
            <p>Conceptual microservice should be independently changeable and deployable</p>
            <p>It should have its own database that’s only accessible by the apps within that conceptual microservice, and it’s a database that’s not directly shared with anything else.</p>
            <br>
            <h3><a href="https://medium.com/@priyamjpatel/how-microservices-architecture-contributes-to-scalability-280c43562847">Scalability</a></h3>
            <h4>Definition:</h4>
            <p>Ability of a microservices-based system to handle increased workload efficiently by either adding resources or optimizing existing ones</p>
            <p> - Vertical: Add more resources (such as CPU, memory, or storage) allocated to an individual microservice instance</p>
            <p> - Horizontal: Add more instances of a microservice to distribute the load. When a specific microservice experiences increased demand, deploy additional instances to share the load.</p>
            <h4>Strategies to make Microservices scallable</h4>
            <p><strong>Load balancing:</strong></p>
            <p>Distribute incoming traffic evenly among multiple instances of the same microservice.</p>
            <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240603140952/Load-balancing-in-Microservices-Architecture.webp" alt="load balancer">
            <p>Popular load balancing solutions include NGINX, HAProxy, and cloud-based load balancers offered by AWS, Azure, and Google Cloud.</p>
            <p><strong>Auto-scaling</strong></p>
            <p>Use provider tools to automatically scale microservices up or down based on predefined triggers to ensure match the workload</p>
            <p><strong>Containerization</strong></p>
            <p>Use Containerization tools like Docker and container orchestrations platforms like Kubernets</p>
            <p>Container help package and deploy microservices consistently across different environments easier</p>
            <p><strong>Database sharding</strong></p>
            <p>Partition data horiziontally across multiple database instances. Enhance database performance.</p>
            <p><strong>Mornitoring, Caching, Statelessness</strong></p>
            <br>
            <h3><a href="https://www.codingknownsense.com/microservices-design-principle-resiliency/">Resiliency</a></h3>
            <p><a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/">Microsoft doc</a> for more technical</p>
            <h4>Definition: </h4>
            <p>Is making our software reliable and available and ensuring that if we do have any failures within our back‑end microservices, each service fails fast and there’s alternate functionality so that the user doesn’t face any disruption.</p>
            <h4>Design for failure</h4>
            <p>Design the microservices with the expectation that cascading failures happen and our microservices have to handle it as smoothly as possible</p>
            <p>Avoid letting user face any disruption when error happends by providing alternative functionalities</p>
            <p>Assumme that the thrid-party API is inconsistent and could possiply have connectivity issues. We should place a shield between external API and our microservices</p>
            <h4>Resiliency patterns</h4>
            <p><strong>Circuit breaker pattern</strong></p>
            <p>Main idea: Allow a service or application to keep a count on how many failures it receives from a downstream component</p>
            <p>After a certain number of retries, it stops trying to connect and allow service's code to fail quickly so that we can response back to clients</p>
            <p>At the same time, we can provide alternative functionalities</p>
            <p>After a time, the pattern will try that component again to see if it is recovered</p>
            <p>Usecase:</p>
            <ul>
                <li>Dealing with external service</li>
                <li>Handling latency</li>
                <li>Need better fault tolerance</li>
            </ul>
            <p><strong>Retry pattern</strong></p>
            <p>Used to handle transient failures by automatically reattempting failed operations</p>
            <p>Retrying the operation a predefined number of times, with delays in between each attempt.</p>
            <p>Usecase:</p>
            <ul>
                <li>Network glitches or a brief unavailable time of service</li>
                <li>Reduce mannual intervention in handling routing or recoverable errors</li>
                <li>Used witk load balancing to distribute requests more evenly</li>
            </ul>
            <p><strong>Timeout pattern</strong></p>
            <p>Setting a time limit for a services operation to complete.</p>
            <p>If the operation exceeds this limit, it’s considered a timeout, and the system can respond accordingly.</p>
            <p>Usecase:</p>
            <ul>
                <li>When need to guarantee on the maximum time the service have to response within. Ensure slow service will not impact the system overall performance</li>
                <li>Need to manage resource for other services rather than a slow one</li>
            </ul>
            <p><strong>Caching</strong></p>
            <p>Strore and retrieve frequently used data in a high-speed, temporary storage location</p>
            <p>Usecase</p>
            <ul>
                <li>Reduce latency and minimize the load</li>
                <li>When we have high data access frequency</li>
                <li></li>
            </ul>
            <h4>Active backup</h4>
            <p>Another key strategy in order to achieve the resiliency design principle is to have active backups of everything</p>
            <p>Key point: <strong>Active</strong> - The backup components are actively receiving a load of the traffic</p>
            <p>Not passive backup: the backup components just sit and wait for errors to be used</p>
            <h4>Network health</h4>
            <p>We should have a central monitoring system that monitors the network for connection outages, for latency issues, and for timeouts so that we can use all this information and all these metrics and stats for capacity planning.</p>
            <h4>Validate connection and data</h4>
            <p>validate data: Format, ...</p>
            <p>connection: Authen, Authorize, priviledges,...</p>
            <h4>Proactive maintenance</h4>
            <p>Central loggin, central mornitoring,...</p>
        </section>
        <br>
        <section class="service-to-service-communication">
            <h1><a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/communication-in-microservice-architecture">Service-to-Service communication: Synchronous and Asynchronous</a></h1>
            <p><a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/communication-in-microservice-architecture">Microsoft doc</a></p>
            <p><a href="https://dev.to/devcorner/service-to-service-communication-in-microservice-architectures-a-detailed-guide-4jck">Dev Community Doc</a></p>
            <p>In a microservices architecture, service-to-service communication is how one microservice talks to another — typically over HTTP, gRPC, or messaging queues.</p>
            <p>types of communications can be classified in two axes</p>
            <p>First axis is Synchronous vs Asynchronous</p>
            <p>The second is Single receiver and Multiple receivers
            The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service. Microservices also typically use messaging protocols for asynchronous communication between microservices.>
            <h2><a href="https://www.codingknownsense.com/technologies-for-microservices/synchronous-communication/">Synchronous communication</a></h2>
            <p>Making request and waiting for response</p>
            <p>The protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</p>
            <h3>REST API</h3>
            <p>The services expose API endpoint, communicate using HTTP methods like GET, POST, PUT, DELETE</p>
            <p>Exchange payload like JSON or XML</p>
            <p>Request/response communication is especially well suited for querying data for a real-time </p>
            <img src="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png" alt="HTTP Communication">
            <h3>gRPC</h3>
            <p><a href="https://www.atatus.com/blog/what-is-grpc-framework/">What is RCP</a></p>
            <p>gRPC is a high-performance, language-agnostic remote procedure call (RPC) framework.</p>
            <p>It supports synchronous communication by allowing one microservice to call a method on another microservice as if it were a local function call.</p>
            <p>gRPC is efficient, supports streaming, and provides features like authentication and load balancing.</p>
            <h2><a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/asynchronous-message-based-communication">Asynchronous - Message base communication</a></h2>
            <p>The client code or message sender usually doesn't wait for a response.</p>
            <p>When using messaging, processes communicate by exchanging messages asynchronously. A client makes a command or a request to a service by sending it a message. If the service needs to reply, it sends a different message back to the client. Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</p>
            <p>use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</p>
            <p>There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication. </p>
            <h3>Single-receiver message-based communication</h3>
            <img src="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/asynchronous-message-based-communication/single-receiver-message-based-communication.png" alt="">
            <h3>Multiple-receivers message-based communication</h3>
            <p>As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications. Thus, it helps you to follow the open/closed principle in the sending service. That way, additional subscribers can be added in the future without the need to modify the sender service.</p>
        </section>
        <section class="DDD">
            <h1><a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice">Domain-Driven Design (DDD)</a></h1>
            <p>Problems = domains</p>
            <p>Describe each independent problems as Area Bounded Contexts, each Bounded Context correlates to a microservice</p>
            <p>DDD approaches should be applied only if you are implementing complex microservices with significant business rules. </p>
            <h2>Keep the microservice context boundaries relatively small</h2>
            <p>Two goals:</p>
            <p>First, aim to create the microservices as small as possiole. Create boundary around things that need cohesion</p>
            <p>Second, Avoid chatty communiation between services</p>
            <P>should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context</P>
            <p>If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</p>
            <h2>Layers in DDD </h2>
            <img src="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/ddd-oriented-microservice/domain-driven-design-microservice.png" alt="">
            <p>There are 3 layers: Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</p>
            <p>Design a system so that each layer can only communicate with certain other layers</p>
            <p>For instance, the domain model layer should not take a dependency on any other layer</p>
            <h2>The domain model layer</h2>
            <p>
                Responsible for representing concepts of the business, information about the business situation, and business rules. State that reflects the business situation is controlled and used here, 
                even though the technical details of storing it are delegated to the infrastructure. 
                This layer is the heart of business software.
            </p>
            <p>This layer must completely ignore data persistence details</p>
            <p>Domain model entity classes should be POCOs (Plain Old CLR Object)</p>
            <p>Domain Entity should not have any direct dependency (like deriving from a base class) or have data access framework like EntityFramework</p>
            <h2>The Application Layer</h2>
            <p>This layer define the jobs that application need to do</p>
            <p>Does not contain business rules or knowledge</p>
            <p>Coorodinate tasks and delegate works for collaborations of domain objects in the next layer</p>
            <p>Does not have state to relfect the business situation, but can have state to reflect the progress</p>
            <p>A microservice's application layer in .NET is commonly coded as an ASP.NET Core Web API project.
                The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates)
            </p>
            <p>Basically, the application logic is where you implement all use cases that depend on a given front end. For example, the implementation related to a Web API service.</p>
            <p>Domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</p>
            <p>Most of all, the domain model layer must not directly depend on any infrastructure framework.</p>
            <h2>The Infrastructure Layer</h2>
            <p>Present how data in Domain Layer being managed in other presistent storage (Database,...)</p>
            <p>Example: Using EntityFrameword, implement DbContext</p>
            <p>The infrastructure layer must not "contaminate" the domain model layer</p>
            <p>Dependency in the DDD applciation</p>
            <img src="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/ddd-oriented-microservice/ddd-service-layer-dependencies.png" alt="DDD Application Dependncies">
            <p>Dependencies in a DDD Service, the Application layer depends on Domain and Infrastructure, and Infrastructure depends on Domain, but Domain doesn't depend on any layer.</p>
            <p><strong>Question: How DDD helps define microservices boundaries</strong></p>
            <p><strong>Answer:</strong></p>
            <p>A Bounded Context in DDD is equivalence to a Microservice boudary</p>
            <p>Each microservice should own one bounded context, including own data model, business logic and language (Ubiquitous)</p>
            <p>DDD encourages putting business rules into entities and aggregates, rather than in service methods. More autonomous microservices, better consistency enforcement and less duplication of business rules</p>
            <p>Aggregate Roots define Transaction Boundaries, so you design services that can complete transactions independently and no need for distributed transactions</p>
        </section>
        <section class="database-management">
            <h1>Database management</h1>
            <table border="1" cellpadding="8" cellspacing="0">
                <thead>
                    <tr>
                    <th>Aspect</th>
                    <th>Database Per Service Pattern</th>
                    <th>Shared Database Pattern</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                    <td><strong>Definition</strong></td>
                    <td>Each microservice has its own private database</td>
                    <td>Multiple microservices share a single database</td>
                    </tr>
                    <tr>
                    <td><strong>Coupling</strong></td>
                    <td>Loose coupling between services</td>
                    <td>Tight coupling between services</td>
                    </tr>
                    <tr>
                    <td><strong>Schema Management</strong></td>
                    <td>Independent schema evolution for each service</td>
                    <td>Shared schema, changes affect all services</td>
                    </tr>
                    <tr>
                    <td><strong>Scalability</strong></td>
                    <td>Easier to scale services independently</td>
                    <td>Difficult to scale services independently</td>
                    </tr>
                    <tr>
                    <td><strong>Performance</strong></td>
                    <td>Optimized performance, no contention</td>
                    <td>Risk of data contention and performance bottlenecks</td>
                    </tr>
                    <tr>
                    <td><strong>Fault Isolation</strong></td>
                    <td>Improved fault isolation</td>
                    <td>Failure in the database affects all services</td>
                    </tr>
                    <tr>
                    <td><strong>Technological Choice</strong></td>
                    <td>Each service can choose its own database technology</td>
                    <td>Limited, as all services must use the same database technology</td>
                    </tr>
                    <tr>
                    <td><strong>Data Consistency</strong></td>
                    <td>Challenges in maintaining data consistency across services</td>
                    <td>Easier to enforce data consistency across services</td>
                    </tr>
                    <tr>
                    <td><strong>Complexity</strong></td>
                    <td>More complex to manage multiple databases</td>
                    <td>Simpler to manage a single database</td>
                    </tr>
                    <tr>
                    <td><strong>Use Case</strong></td>
                    <td>Suitable for complex, modular systems with diverse needs</td>
                    <td>Suitable for simpler systems with tightly related services</td>
                    </tr>
                </tbody>
                </table>



        </section>
    </div>
    <div class="related">
        <p><a href="https://deviq.com/antipatterns/iceberg-class">DevIq</a></p>
    </div>
</div>
