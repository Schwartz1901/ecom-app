<div class="wrapper">
    <div class="title">
        <h1>Week 4: Develop full Web application using Angular and .NET Core.</h1>
        <div class="summary-section">
            <p>
                Now the time for some fullstack stuffs. Getting familiar with how to connect Frontend and Backend.
            </p>
        </div>
    </div>
    <hr class="divider">
    <div class="goals">
        <h2>Goals:</h2>
        <app-checklist [storageKey]="'week4'"></app-checklist>
    </div>
    <hr class="divider">
    <div class="main-content">
        <section class="call-api">
            <h2>Call Web API</h2>
            <p>In Angular, we call API by using HttpClientModule. First we register HttpClientModule in the app</p>
            <app-script-widget 
                title="app.config.ts"
                [content]="appConfigTsHtml"
            />
            Then inject it into the services for calling API
            <app-script-widget 
                title="service.ts"
                [content]="serviceInjectHtml"
            />
            This is example of calling a simple API endpoint.
            <app-script-widget 
                [content]="sayHElloHtml"
            />
            <p>
                A HttpClient instance provide methods GET, POST, PUT, DELETE,... and will return an Observable object with generic type T.
                Observable objects are lazy, so we need to do something with them otherwise they never send HTTP request.
            </p>
            <h3>.pipe() and .subcribe()</h3>
            <p><strong>.pipe()</strong> is used for processing the data before it's consumed.</p>
            <p>It will return a new Observable object</p>
            <p>We will use it for handle the error sent from backend</p>
            <p><strong>.subcribe()</strong> is the one that actually executes an observable object</p>
            <h4>Best practice</h4>
            <p>In service.ts, use .pipe() to return an Observable object to component</p>
            <p>In component.ts, .subscribe() on the Observable object returned to send Http request</p>
            <app-script-widget 
                [content] = "callHeloHtml"
            />
            <div class=call-api-exp>
            
                <button (click)="callHello()">Say Hello</button>
                <p>(no error handling) Response: {{hello()}} </p>
            </div>
            
            
            <h2>Handle return data and errors</h2>
            <p>Even most of the errors we handled in backend, sometime we still want to monitor the errors to the frontend, or avoid throwing error log while the backend server shut down</p>
            <p>Ultilize the combination of .pipe() and .subscribe()</p>
            <p>In .pipe() block, we define all the posible error and response respectively</p>

            <app-script-widget 
                [content]="pipeHtml"
            />
            <p> In .subscribe() block</p>
            <app-script-widget
                [content]="subscribeHtml"
            />
            <p>Example: This is the button above with better error handling</p>
            <div class=call-api-exp>
            
                <button (click)="callHelloHandle()">Say Hello</button>
                <p>Response: {{helloHandle()}} </p>
            </div>

            <h3>CORS Policy</h3>
            <p>
                CORS stands for Cross-Origin Resource Sharing.
                It is a security mechanism built into web browsers that controls whether a web page 
                from one origin (domain) is allowed to access resources from a different origin.
            </p>
            <p>
                We have to allow our front end server to request API.
            </p>
            <p>Adding CORS Policy</p>
            <app-script-widget 
                title="Program.cs"
                [content]="corsPolicyHtml"
            />
        </section>
        <section class = "HttpClient">
            <h2>HttpClient in backend</h2>
            <p>In Backend, we can use HttpClient to call API endpoints from external party as long as we are allowed to do so</p>
            <p>For example, this is a public API to get random generated user JSON file</p>
            <a>https://randomuser.me/api/</a>
            <p>Sample result</p>
            <img src ="../../../../public/document_img/week4/sample_result.PNG" alt="sample result">
            <img src="../../../../public/document_img/week4/postman_GET_randomUserApi.PNG" alt="sample result">
            <h3><a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines">HttpClient</a></h3>
            <p>HttpClient is a built-in class in .NET used to send HTTP requests and receive HTTP responses from external services â€” like calling a REST API from your backend.</p>
            <h4>Recommended use (by Micrisoft):</h4>
            <p>To summarize recommended HttpClient use in terms of lifetime management, you should use either long-lived clients and set <strong>PooledConnectionLifetime</strong> (.NET Core and .NET 5+) or short-lived clients created by <strong>IHttpClientFactory</strong>.</p>
            <h3>Socket Exhaustion problem with HttpClient</h3>
            <p>When use <code>new HttpClient()</code> directly, for every request (without reusing it), each will internally create a new connection.</p>
            <p>TCP port will not be release after the connection closed, but stay in TIME_WAIT. Large amount of requests without reusing the connection will soon run out of the available sockets</p>
            <p><strong>Solution:</strong> reuse HttpClient conenction</p>
            <p>In this example, we will use IHttpClientFactory</p>
            <p>Register HttpClient in Program.cs</p>
            <app-script-widget 
                content="builder.Services.AddHttpClient();"
            />
            <p>Inject into service and using it</p>
            <app-script-widget 
                title="ExternalAPIService.cs"
                [content]="randomUserExternalApiHtml"
            />
            <p>Test with postman, calling our endpoint this time</p>
            <img src="../../../../public/document_img/week4/postman_GET_externalAPIEx.PNG" alt="random user">
            <app-api-tester [(baseUrl)]="randomUserUrl"/>
            

        </section>
    </div>
</div>
